#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright: (c) 2025, Gaëtan Trellu <gaetan.trellu@suse.com>
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import absolute_import, division, print_function

__metaclass__ = type

DOCUMENTATION = r"""
---
module: activationkey
short_description: Manage activation keys in SUSE Multi-Linux Manager
description:
  - Create, update, or delete activation keys in SUSE Multi-Linux Manager.
  - Manage software channels and packages associated with activation keys.
  - This module uses the SUSE Multi-Linux Manager API to manage activation keys.
author: Gaëtan Trellu (@goldyfruit) <gaetan.trellu@suse.com>
version_added: '1.0.0'
extends_documentation_fragment:
  - goldyfruit.mlm.mlm_auth
options:
  key_name:
    description:
      - Name of the activation key.
      - The actual activation key will be prefixed with the organization ID.
      - For example, if you specify "mykey" and belong to organization ID 100, the actual key will be "100-mykey".
      - Leave empty or omit to have a new key autogenerated.
      - Required when state=absent (to specify which key to delete).
    type: str
    required: false
  state:
    description:
      - Whether the activation key should exist or not.
      - When C(present), the activation key will be created if it doesn't exist or updated if it does.
      - When C(absent), the activation key will be deleted if it exists.
    type: str
    choices: [ present, absent ]
    default: present
  description:
    description:
      - Description of the activation key.
      - Only used when state=present.
    type: str
    required: false
  base_channel_label:
    description:
      - Base channel label for the activation key.
      - Only used when state=present.
    type: str
    required: false
  usage_limit:
    description:
      - Usage limit for the activation key.
      - Set to 0 for unlimited usage.
      - Only used when state=present.
      - Ignored if unlimited_usage_limit is set to true.
    type: int
    required: false
  unlimited_usage_limit:
    description:
      - Set to true for unlimited usage.
      - When true, this overrides the usage_limit parameter.
      - Only used when state=present.
    type: bool
    required: false
  universal_default:
    description:
      - Whether this activation key should be universal default.
      - Only used when state=present.
    type: bool
    required: false
  disabled:
    description:
      - Whether this activation key should be disabled.
      - Disabled activation keys cannot be used for system registration.
      - Only used when state=present.
    type: bool
    required: false
  contact_method:
    description:
      - The contact method for systems using this activation key.
      - Determines how the SUSE Multi-Linux Manager server contacts client systems.
      - Only used when state=present.
    type: str
    choices: [ default, ssh-push, ssh-push-tunnel ]
    required: false
  entitlements:
    description:
      - Add-on system type labels to associate with the activation key.
      - Valid entitlements include container_build_host, monitoring_entitled, osimage_build_host, virtualization_host, ansible_control_node, proxy_entitled.
      - Only used when state=present and entitlement_state is specified.
    type: list
    elements: str
    choices:
      - container_build_host
      - monitoring_entitled
      - osimage_build_host
      - virtualization_host
      - ansible_control_node
      - proxy_entitled
    required: false
  entitlement_state:
    description:
      - Whether entitlements should be present or absent.
      - Only applies when entitlements is specified.
    type: str
    choices: [ present, absent ]
    default: present
  child_channels:
    description:
      - List of child channel labels to associate with the activation key.
      - Only used when state=present and channel_state is specified.
    type: list
    elements: str
    required: false
  channel_state:
    description:
      - Whether child channels should be present or absent.
      - Only applies when child_channels is specified.
    type: str
    choices: [ present, absent ]
    default: present
  packages:
    description:
      - List of package names to associate with the activation key.
      - Only used when state=present and package_state is specified.
    type: list
    elements: str
    required: false
  package_state:
    description:
      - Whether packages should be present or absent.
      - Only applies when packages is specified.
    type: str
    choices: [ present, absent ]
    default: present
  server_groups:
    description:
      - List of server group names to associate with the activation key.
      - Only used when state=present and server_group_state is specified.
    type: list
    elements: str
    required: false
  server_group_state:
    description:
      - Whether server groups should be present or absent.
      - Only applies when server_groups is specified.
    type: str
    choices: [ present, absent ]
    default: present
notes:
  - This module requires the SUSE Multi-Linux Manager API to be accessible from the Ansible controller.
  - The user running this module must have the appropriate permissions to manage activation keys.
  - When deleting an activation key, all associated configurations will be removed.
  - Deleting an activation key is a destructive operation and cannot be undone.
requirements:
  - python >= 3.6
"""

EXAMPLES = r"""
# Using credentials configuration file (recommended)
- name: Create a new activation key using credentials file
  goldyfruit.mlm.activationkey:
    # No credentials needed - loaded from ~/.config/smlm/credentials.yaml
    key_name: "sles-15-key"
    description: "SLES 15 activation key"
    base_channel_label: "sles15-sp4-pool-x86_64"
    usage_limit: 100
    state: present
  register: key_result

- name: Create activation key with autogenerated name (empty string)
  goldyfruit.mlm.activationkey:
    key_name: ""  # Empty string for autogenerated key
    description: "Autogenerated SLES 15 activation key"
    base_channel_label: "sles15-sp4-pool-x86_64"
    usage_limit: 0  # Unlimited usage
    state: present

- name: Create activation key with autogenerated name (omit key_name)
  goldyfruit.mlm.activationkey:
    # key_name omitted - will be autogenerated
    description: "Autogenerated SLES 15 activation key"
    base_channel_label: "sles15-sp4-pool-x86_64"
    usage_limit: 0  # Unlimited usage
    state: present

- name: Create activation key using specific instance
  goldyfruit.mlm.activationkey:
    instance: staging  # Use staging instance from credentials file
    key_name: "staging-sles-15-key"
    description: "SLES 15 activation key for staging"
    base_channel_label: "sles15-sp4-pool-x86_64"
    usage_limit: 50
    state: present

- name: Create activation key with entitlements
  goldyfruit.mlm.activationkey:
    key_name: "virtualization-key"
    description: "Activation key with virtualization entitlements"
    base_channel_label: "sles15-sp4-pool-x86_64"
    usage_limit: 25
    entitlements:
      - virtualization_host
      - monitoring_entitled
    universal_default: true
    state: present

- name: Update activation key description
  goldyfruit.mlm.activationkey:
    key_name: "sles-15-key"
    description: "Updated SLES 15 activation key"
    state: present

- name: Create activation key with unlimited usage
  goldyfruit.mlm.activationkey:
    key_name: "unlimited-key"
    description: "Activation key with unlimited usage"
    base_channel_label: "sles15-sp4-pool-x86_64"
    unlimited_usage_limit: true
    state: present

- name: Create disabled activation key
  goldyfruit.mlm.activationkey:
    key_name: "disabled-key"
    description: "Disabled activation key"
    base_channel_label: "sles15-sp4-pool-x86_64"
    disabled: true
    state: present

- name: Create activation key with SSH push contact method
  goldyfruit.mlm.activationkey:
    key_name: "ssh-push-key"
    description: "Activation key with SSH push contact method"
    base_channel_label: "sles15-sp4-pool-x86_64"
    contact_method: "ssh-push"
    state: present

- name: Update activation key with new settings
  goldyfruit.mlm.activationkey:
    key_name: "existing-key"
    description: "Updated activation key"
    unlimited_usage_limit: true
    disabled: false
    contact_method: "ssh-push-tunnel"
    state: present

- name: Add child channels to activation key
  goldyfruit.mlm.activationkey:
    key_name: "sles-15-key"
    child_channels:
      - "sles15-sp4-updates-x86_64"
      - "sles15-sp4-installer-updates-x86_64"
    channel_state: present
    state: present

- name: Add packages to activation key
  goldyfruit.mlm.activationkey:
    key_name: "sles-15-key"
    packages:
      - "vim"
      - "htop"
      - "curl"
    package_state: present
    state: present

- name: Remove packages from activation key
  goldyfruit.mlm.activationkey:
    key_name: "sles-15-key"
    packages:
      - "htop"
    package_state: absent
    state: present

- name: Add server groups to activation key
  goldyfruit.mlm.activationkey:
    key_name: "sles-15-key"
    server_groups:
      - "Production Servers"
      - "Web Servers"
      - "Database Servers"
    server_group_state: present
    state: present

- name: Remove server groups from activation key
  goldyfruit.mlm.activationkey:
    key_name: "sles-15-key"
    server_groups:
      - "Database Servers"
    server_group_state: absent
    state: present

- name: Add entitlements to activation key
  goldyfruit.mlm.activationkey:
    key_name: "sles-15-key"
    entitlements:
      - "virtualization_host"
      - "monitoring_entitled"
      - "ansible_control_node"
    entitlement_state: present
    state: present

- name: Remove entitlements from activation key
  goldyfruit.mlm.activationkey:
    key_name: "sles-15-key"
    entitlements:
      - "monitoring_entitled"
    entitlement_state: absent
    state: present

- name: Delete an activation key
  goldyfruit.mlm.activationkey:
    key_name: "sles-15-key"
    state: absent

# Traditional method with explicit credentials (still supported)
- name: Create activation key with explicit credentials
  goldyfruit.mlm.activationkey:
    url: https://suma.example.com
    username: admin
    password: admin
    key_name: "sles-15-key"
    description: "SLES 15 activation key"
    base_channel_label: "sles15-sp4-pool-x86_64"
    usage_limit: 100
    state: present
"""

RETURN = r"""
activation_key:
  description: Information about the managed activation key.
  returned: when state=present and the activation key exists or was created
  type: dict
  contains:
    id:
      description: Activation key ID.
      type: int
      sample: 42
    key:
      description: Activation key name.
      type: str
      sample: "sles-15-key"
    description:
      description: Activation key description.
      type: str
      sample: "SLES 15 activation key"
    base_channel_label:
      description: Base channel label for the activation key.
      type: str
      sample: "sles15-sp4-pool-x86_64"
    usage_limit:
      description: Usage limit for the activation key.
      type: int
      sample: 100
    system_count:
      description: Number of systems using this activation key.
      type: int
      sample: 5
    disabled:
      description: Whether the activation key is disabled.
      type: bool
      sample: false
    universal_default:
      description: Whether this is a universal default activation key.
      type: bool
      sample: false
    child_channel_labels:
      description: List of child channel labels associated with the activation key.
      type: list
      elements: str
      sample: ["sles15-sp4-updates-x86_64"]
    packages:
      description: List of packages associated with the activation key.
      type: list
      elements: str
      sample: ["vim", "curl"]
msg:
  description: Status message describing the result of the operation.
  returned: always
  type: str
  sample: "Activation key 'sles-15-key' created successfully"
"""

from ansible.module_utils.basic import AnsibleModule
from ansible_collections.goldyfruit.mlm.plugins.module_utils.mlm_client import (
    MLMClient,
    mlm_argument_spec,
)
from ansible_collections.goldyfruit.mlm.plugins.module_utils.mlm_activationkey_utils import (
    create_activation_key,
    update_activation_key,
    delete_activation_key,
    manage_activation_key_channels,
    manage_activation_key_packages,
    manage_activation_key_server_groups,
    manage_activation_key_entitlements,
    get_activation_key_by_name,
)


def main():
    """
    Main module execution.

    This function is the entry point for the Ansible module. It:
    1. Defines the module arguments and creates the AnsibleModule instance
    2. Creates the MLM client and logs in to the API
    3. Determines the action to take based on the 'state' parameter
    4. Calls the appropriate function to perform the action
    5. Returns the result to Ansible
    6. Ensures proper logout from the API

    The module supports check mode, which allows for dry runs without making
    actual changes to the system.
    """
    # Define the module arguments
    argument_spec = mlm_argument_spec()
    argument_spec.update(
        key_name=dict(type="str", required=False),
        state=dict(type="str", default="present", choices=["present", "absent"]),
        description=dict(type="str", required=False),
        base_channel_label=dict(type="str", required=False),
        usage_limit=dict(type="int", required=False),
        unlimited_usage_limit=dict(type="bool", required=False),
        universal_default=dict(type="bool", required=False),
        disabled=dict(type="bool", required=False),
        contact_method=dict(
            type="str",
            required=False,
            choices=["default", "ssh-push", "ssh-push-tunnel"],
        ),
        entitlements=dict(
            type="list",
            elements="str",
            required=False,
            choices=[
                "container_build_host",
                "monitoring_entitled",
                "osimage_build_host",
                "virtualization_host",
                "ansible_control_node",
                "proxy_entitled",
            ],
        ),
        entitlement_state=dict(
            type="str", default="present", choices=["present", "absent"]
        ),
        child_channels=dict(type="list", elements="str", required=False),
        channel_state=dict(
            type="str", default="present", choices=["present", "absent"]
        ),
        packages=dict(type="list", elements="str", required=False),
        package_state=dict(
            type="str", default="present", choices=["present", "absent"]
        ),
        server_groups=dict(type="list", elements="str", required=False),
        server_group_state=dict(
            type="str", default="present", choices=["present", "absent"]
        ),
    )

    # Create the module
    module = AnsibleModule(
        argument_spec=argument_spec,
        supports_check_mode=True,
    )

    # Validate that key_name is provided when state=absent
    if module.params["state"] == "absent" and not module.params.get("key_name"):
        module.fail_json(msg="key_name is required when state=absent")

    # Create the MLM client
    client = MLMClient(module)

    # Login to the API
    client.login()

    try:
        # Determine what to do based on the state
        state = module.params["state"]
        key_name = module.params["key_name"]

        if state == "present":
            # Step 1: Ensure the activation key exists
            # Check if the activation key exists (only if key_name is provided)
            existing_key = None
            if key_name:
                existing_key = get_activation_key_by_name(client, key_name)

            if existing_key:
                # Key exists - check if update is needed
                changed, result, msg = update_activation_key(module, client)
                # Get the actual key name (might have org prefix)
                actual_key_name = existing_key.get("key", key_name)
            else:
                # Key doesn't exist - create it first
                changed, result, msg = create_activation_key(module, client)

                # For autogenerated keys, we need to get the actual key name from the result
            if not key_name:
                if isinstance(result, dict) and "key" in result:
                    actual_key_name = result["key"]
                else:
                    # If we can't get it from result, fetch the newly created key
                    keys = client.get("/activationkey/listActivationKeys")
                    if isinstance(keys, dict) and "result" in keys:
                        keys = keys["result"]
                    if isinstance(keys, list) and keys:
                        # Get the most recently created key (assuming it's the last one)
                        actual_key_name = keys[-1].get("key", "")
                    else:
                        module.fail_json(
                            msg="Failed to determine the name of the created activation key"
                        )
            else:
                actual_key_name = key_name

            # Step 2: Now that the activation key is guaranteed to exist, manage channels if specified
            if module.params.get("child_channels"):
                # Update module params with the actual key name for channel management
                module.params["key_name"] = actual_key_name
                ch_changed, ch_result, ch_msg = manage_activation_key_channels(
                    module, client
                )
                if ch_changed:
                    changed = True
                    msg += " {}".format(ch_msg)

            # Step 3: Finally, manage packages if specified
            if module.params.get("packages"):
                # Update module params with the actual key name for package management
                module.params["key_name"] = actual_key_name
                pkg_changed, pkg_result, pkg_msg = manage_activation_key_packages(
                    module, client
                )
                if pkg_changed:
                    changed = True
                    # Only append the message if packages were actually changed
                    if not msg.endswith("already up to date"):
                        msg += " {}".format(pkg_msg)
                    else:
                        # Replace the "already up to date" message with the package action
                        msg = msg.replace(
                            "already up to date", "updated"
                        ) + " {}".format(pkg_msg)
                else:
                    # If packages weren't changed but channels were, don't append anything
                    # If nothing was changed, keep the original message
                    pass

            # Step 3.5: Manage server groups if specified
            if module.params.get("server_groups"):
                # Update module params with the actual key name for server group management
                module.params["key_name"] = actual_key_name
                sg_changed, sg_result, sg_msg = manage_activation_key_server_groups(
                    module, client
                )
                if sg_changed:
                    changed = True
                    # Only append the message if server groups were actually changed
                    if not msg.endswith("already up to date"):
                        msg += " {}".format(sg_msg)
                    else:
                        # Replace the "already up to date" message with the server group action
                        msg = msg.replace(
                            "already up to date", "updated"
                        ) + " {}".format(sg_msg)
                else:
                    # If server groups weren't changed but other things were, don't append anything
                    # If nothing was changed, keep the original message
                    pass

            # Step 3.6: Manage entitlements if specified
            if module.params.get("entitlements"):
                # Update module params with the actual key name for entitlement management
                module.params["key_name"] = actual_key_name
                ent_changed, ent_result, ent_msg = manage_activation_key_entitlements(
                    module, client
                )
                if ent_changed:
                    changed = True
                    # Only append the message if entitlements were actually changed
                    if not msg.endswith("already up to date"):
                        msg += " {}".format(ent_msg)
                    else:
                        # Replace the "already up to date" message with the entitlement action
                        msg = msg.replace(
                            "already up to date", "updated"
                        ) + " {}".format(ent_msg)
                else:
                    # If entitlements weren't changed but other things were, don't append anything
                    # If nothing was changed, keep the original message
                    pass

            # Step 4: Get the final state of the activation key
            final_result = get_activation_key_by_name(client, actual_key_name)
            if not final_result:
                # Fallback to the result from create/update if we can't fetch the key
                final_result = result

            module.exit_json(changed=changed, msg=msg, activation_key=final_result)

        else:  # state == 'absent'
            changed, result, msg = delete_activation_key(module, client)
            module.exit_json(changed=changed, msg=msg)

    except Exception as e:
        module.fail_json(msg="Failed to manage activation key: {}".format(str(e)))
    finally:
        # Logout from the API
        client.logout()


if __name__ == "__main__":
    main()
